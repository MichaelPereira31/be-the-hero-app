{"version":3,"file":"buildAsyncRequire.js","sourceRoot":"","sources":["../../src/async-require/buildAsyncRequire.ts"],"names":[],"mappings":";;;AAAA;;;;;GAKG;AACH,+CAAwC;AAExC,6CAA+C;AAuC/C,iFAAiF;AACjF,SAAgB,iBAAiB,CAAC,YAA0B;IAC1D,MAAM,oBAAoB,GAAyB,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;IAEvE,SAAS,YAAY,CACnB,QAAgB,EAChB,UAAkB,EAClB,KAAwB,EACxB,UAAuC,EAAE,cAAc,EAAE,KAAK,EAAE;QAEhE,IACE,OAAO,CAAC,GAAG,CAAC,QAAQ,KAAK,YAAY;YACrC,4CAA4C;YAC5C,CAAC,uBAAQ,CAAC,EAAE,KAAK,KAAK,IAAI,OAAO,MAAM,KAAK,WAAW,CAAC,EACxD;YACA,oCAAoC;YAEpC,OAAO,OAAO,CAAC,OAAO,EAAE,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC,YAAY,CAAC,SAAS,CAAC,QAAQ,CAAC,CAAC,CAAC;SACvE;QAED,IAAI,OAAO,CAAC,cAAc,EAAE;YAC1B,OAAO,OAAO,CAAC,OAAO,EAAE,CAAC;SAC1B;QAED,MAAM,cAAc,GAAG,MAAM,CAAC,QAAQ,CAAC,CAAC;QACxC,8FAA8F;QAC9F,MAAM,UAAU,GAAG,KAAK,CAAC,cAAc,CAAC,CAAC;QACzC,IAAI,UAAU,EAAE;YACd,kDAAkD;YAClD,IAAI,CAAC,oBAAoB,CAAC,cAAc,CAAC,EAAE;gBACzC,oBAAoB,CAAC,cAAc,CAAC,GAAG,IAAA,4BAAe,EAAC,UAAU,CAAC,CAAC,IAAI,CACrE,GAAG,EAAE,CAAC,YAAY,CAAC,QAAQ,CAAC,CAC7B,CAAC;aACH;YACD,kCAAkC;YAClC,OAAO,oBAAoB,CAAC,cAAc,CAAC,CAAC;SAC7C;QAED,OAAO,YAAY,CAAC,SAAS,CAAC,QAAQ,CAAC,CAAC;IAC1C,CAAC;IAED,YAAY,CAAC,QAAQ,GAAG,UACtB,QAAgB,EAChB,UAAkB,EAClB,KAAwB;QAExB,oCAAoC;QACpC,IAAI,OAAO,CAAC,GAAG,CAAC,QAAQ,KAAK,YAAY,EAAE;YACzC,OAAO;SACR;QACD,MAAM,MAAM,GAAG,YAAY,CAAC,QAAQ,EAAE,UAAU,EAAE,KAAK,EAAE;YACvD,cAAc,EAAE,IAAI;SACrB,CAAC,CAAC;QACH,IAAI,MAAM,YAAY,OAAO,EAAE;YAC7B,MAAM,CAAC,IAAI,CACT,GAAG,EAAE,GAAE,CAAC,EACR,GAAG,EAAE,GAAE,CAAC,CACT,CAAC;SACH;IACH,CAAC,CAAC;IAEF,YAAY,CAAC,QAAQ,GAAG,UACtB,QAAgB,EAChB,UAAkB,EAClB,KAAwB;QAExB,MAAM,IAAI,KAAK,CAAC,qCAAqC,CAAC,CAAC;IACzD,CAAC,CAAC;IAEF,OAAO,YAAY,CAAC;AACtB,CAAC;AArED,8CAqEC","sourcesContent":["/**\n * Copyright Â© 2022 650 Industries.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport { Platform } from \"react-native\";\n\nimport { loadBundleAsync } from \"./loadBundle\";\n\ntype ImportBundleNames = Record<string, string>;\n\ntype MetroRequire = {\n  (id: number): any;\n  importAll: (id: number) => any;\n};\n\ntype ImportBundlePromises = Record<string, Promise<any>> & {\n  __proto__?: null;\n};\n\n/**\n * Must satisfy the requirements of the Metro bundler.\n * https://github.com/facebook/metro/blob/f9fe277986ff7e7e53ae0418040f3aa1eb1c7056/packages/metro/src/ModuleGraph/worker/collectDependencies.js#L629-L639\n *\n * And https://github.com/facebook/metro/blob/fc29a1177f883144674cf85a813b58567f69d545/packages/metro/src/lib/getAppendScripts.js#L54-L56\n */\ntype AsyncRequire = {\n  <TModule>(\n    moduleID: number,\n    moduleName: string,\n    paths: ImportBundleNames,\n    options?: { isPrefetchOnly: boolean }\n  ): Promise<TModule | void> | TModule;\n  prefetch(\n    moduleID: number,\n    moduleName: string,\n    paths: ImportBundleNames\n  ): void;\n  /** NOTE(EvanBacon): Unclear what this should return `__jsResource` ?? */\n  resource(\n    moduleID: number,\n    moduleName: string,\n    paths: ImportBundleNames\n  ): never;\n};\n\n/** Create an `asyncRequire` function in the expected shape for Metro bundler. */\nexport function buildAsyncRequire(metroRequire: MetroRequire): AsyncRequire {\n  const importBundlePromises: ImportBundlePromises = Object.create(null);\n\n  function asyncRequire<TModule>(\n    moduleID: number,\n    moduleName: string,\n    paths: ImportBundleNames,\n    options: { isPrefetchOnly: boolean } = { isPrefetchOnly: false }\n  ): Promise<TModule | void> | TModule {\n    if (\n      process.env.NODE_ENV === \"production\" ||\n      // Disable in static rendering environments.\n      (Platform.OS === \"web\" && typeof window === \"undefined\")\n    ) {\n      // TODO: Don't disable in production\n\n      return Promise.resolve().then(() => metroRequire.importAll(moduleID));\n    }\n\n    if (options.isPrefetchOnly) {\n      return Promise.resolve();\n    }\n\n    const stringModuleID = String(moduleID);\n    // This is basically `__webpack_require__.u` -> returns the bundle path for a numeric moduleID\n    const bundlePath = paths[stringModuleID];\n    if (bundlePath) {\n      // Prevent loading the same module more than once.\n      if (!importBundlePromises[stringModuleID]) {\n        importBundlePromises[stringModuleID] = loadBundleAsync(bundlePath).then(\n          () => metroRequire(moduleID)\n        );\n      }\n      // Return for the user to resolve.\n      return importBundlePromises[stringModuleID];\n    }\n\n    return metroRequire.importAll(moduleID);\n  }\n\n  asyncRequire.prefetch = function (\n    moduleID: number,\n    moduleName: string,\n    paths: ImportBundleNames\n  ): void {\n    // TODO: Don't disable in production\n    if (process.env.NODE_ENV === \"production\") {\n      return;\n    }\n    const result = asyncRequire(moduleID, moduleName, paths, {\n      isPrefetchOnly: true,\n    });\n    if (result instanceof Promise) {\n      result.then(\n        () => {},\n        () => {}\n      );\n    }\n  };\n\n  asyncRequire.resource = function (\n    moduleID: number,\n    moduleName: string,\n    paths: ImportBundleNames\n  ): never {\n    throw new Error(\"Unimplemented Metro runtime feature\");\n  };\n\n  return asyncRequire;\n}\n"]}
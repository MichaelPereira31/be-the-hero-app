"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildAsyncRequire = void 0;
/**
 * Copyright Â© 2022 650 Industries.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
const react_native_1 = require("react-native");
const loadBundle_1 = require("./loadBundle");
/** Create an `asyncRequire` function in the expected shape for Metro bundler. */
function buildAsyncRequire(metroRequire) {
    const importBundlePromises = Object.create(null);
    function asyncRequire(moduleID, moduleName, paths, options = { isPrefetchOnly: false }) {
        if (process.env.NODE_ENV === "production" ||
            // Disable in static rendering environments.
            (react_native_1.Platform.OS === "web" && typeof window === "undefined")) {
            // TODO: Don't disable in production
            return Promise.resolve().then(() => metroRequire.importAll(moduleID));
        }
        if (options.isPrefetchOnly) {
            return Promise.resolve();
        }
        const stringModuleID = String(moduleID);
        // This is basically `__webpack_require__.u` -> returns the bundle path for a numeric moduleID
        const bundlePath = paths[stringModuleID];
        if (bundlePath) {
            // Prevent loading the same module more than once.
            if (!importBundlePromises[stringModuleID]) {
                importBundlePromises[stringModuleID] = (0, loadBundle_1.loadBundleAsync)(bundlePath).then(() => metroRequire(moduleID));
            }
            // Return for the user to resolve.
            return importBundlePromises[stringModuleID];
        }
        return metroRequire.importAll(moduleID);
    }
    asyncRequire.prefetch = function (moduleID, moduleName, paths) {
        // TODO: Don't disable in production
        if (process.env.NODE_ENV === "production") {
            return;
        }
        const result = asyncRequire(moduleID, moduleName, paths, {
            isPrefetchOnly: true,
        });
        if (result instanceof Promise) {
            result.then(() => { }, () => { });
        }
    };
    asyncRequire.resource = function (moduleID, moduleName, paths) {
        throw new Error("Unimplemented Metro runtime feature");
    };
    return asyncRequire;
}
exports.buildAsyncRequire = buildAsyncRequire;
//# sourceMappingURL=buildAsyncRequire.js.map
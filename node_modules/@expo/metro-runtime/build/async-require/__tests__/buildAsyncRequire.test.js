"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.asMock = void 0;
const buildAsyncRequire_1 = require("../buildAsyncRequire");
const loadBundle_1 = require("../loadBundle");
const asMock = (fn) => fn;
exports.asMock = asMock;
jest.mock("../loadBundle", () => ({
    loadBundleAsync: jest.fn(async () => { }),
}));
function getMockRequire() {
    const mockRequire = jest.fn();
    mockRequire.importAll = jest.fn();
    return mockRequire;
}
const originalEnv = process.env.NODE_ENV;
beforeEach(() => {
    process.env.NODE_ENV = "development";
});
afterAll(() => {
    process.env.NODE_ENV = originalEnv;
});
it(`builds required object`, async () => {
    const _require = getMockRequire();
    const asyncRequire = (0, buildAsyncRequire_1.buildAsyncRequire)(_require);
    expect(asyncRequire).toBeInstanceOf(Function);
    expect(asyncRequire.prefetch).toBeInstanceOf(Function);
    expect(asyncRequire.resource).toBeInstanceOf(Function);
});
it(`loads the module with \`loadBundleAsync\` if the module has not been loaded already`, async () => {
    const _require = getMockRequire();
    const asyncRequire = (0, buildAsyncRequire_1.buildAsyncRequire)(_require);
    const myModule = asyncRequire(650, "", { "650": "SixFiveZero" });
    expect(myModule).toEqual(expect.any(Promise));
    // Did attempt to fetch the bundle
    expect(loadBundle_1.loadBundleAsync).toBeCalledWith("SixFiveZero");
    expect(_require.importAll).not.toBeCalled();
});
it(`fetches and returns an async module`, async () => {
    const _require = getMockRequire();
    (0, exports.asMock)(_require).mockReturnValueOnce({ foo: "bar" });
    const asyncRequire = (0, buildAsyncRequire_1.buildAsyncRequire)(_require);
    expect(asyncRequire).toBeInstanceOf(Function);
    const myModule = await asyncRequire(2, "", {
        "2": "Two",
    });
    // Fetch and load the bundle into memory.
    expect(loadBundle_1.loadBundleAsync).toBeCalledWith("Two");
    // Ensure the module was required using Metro after the bundle was loaded.
    expect(_require).toBeCalledWith(2);
    // Ensure the module was returned.
    expect(myModule).toEqual({ foo: "bar" });
});
it(`disables async requires in production`, async () => {
    process.env.NODE_ENV = "production";
    const _require = getMockRequire();
    (0, exports.asMock)(_require.importAll).mockReturnValueOnce({ foo: "bar" });
    const asyncRequire = (0, buildAsyncRequire_1.buildAsyncRequire)(_require);
    expect(asyncRequire).toBeInstanceOf(Function);
    const myModule = await asyncRequire(2, "", {
        "2": "Two",
    });
    // Fetch and load the bundle into memory.
    expect(loadBundle_1.loadBundleAsync).not.toBeCalled();
    // Ensure the module was required using Metro after the bundle was loaded.
    expect(_require.importAll).toBeCalledWith(2);
    expect(_require).not.toBeCalled();
    // Ensure the module was returned.
    expect(myModule).toEqual({ foo: "bar" });
});
//# sourceMappingURL=buildAsyncRequire.test.js.map